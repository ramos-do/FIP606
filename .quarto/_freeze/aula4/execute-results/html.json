{
  "hash": "5843f95def418e177a3c206f42c06afc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Aula 4\"\nauthor: Danilo Oliveira Ramos\nformat: html\n---\n\n\n\n\n# An√°lise de dados\n\n## **Importa√ß√£o dos dados**\n\nFoi utilizado o pacote `readxl` para importar a aba `\"fungicida_campo\"` do arquivo `dados-diversos.xlsx`, contendo dados de produtividade (`PROD`), severidade da ferrugem (`FER`), desfolha (`DFC`), tratamentos (`TRAT`) e blocos (`BLOCO`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## aula 30/04 \nlibrary(readxl)\n\ncampo <- readxl::read_excel(\"dados-diversos.xlsx\", sheet = \"fungicida_campo\")\n\n\n\ncampo$TRAT <- factor(campo$TRAT)\ncampo$BLOCO <- factor(campo$BLOCO)\nm_campo <- lm(log(FER) ~ BLOCO + TRAT, data = campo)\nanova(m_campo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: log(FER)\n          Df  Sum Sq Mean Sq F value    Pr(>F)    \nBLOCO      3  0.2064 0.06880  1.7961    0.1788    \nTRAT       7 11.5210 1.64585 42.9665 4.838e-11 ***\nResiduals 21  0.8044 0.03831                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(emmeans)\nlibrary(dplyr)\nlibrary(DHARMa)\nplot(simulateResiduals(m_campo))\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmeans_campo <- emmeans(m_campo, ~ TRAT, type = \"response\")\nmeans_campo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n TRAT response    SE df lower.CL upper.CL\n 1       20.02 1.960 21    16.33    24.54\n 2        5.68 0.556 21     4.63     6.96\n 3        3.81 0.373 21     3.11     4.67\n 4        3.08 0.301 21     2.51     3.78\n 5        3.24 0.317 21     2.64     3.97\n 6        2.98 0.292 21     2.43     3.65\n 7        3.37 0.330 21     2.75     4.13\n 8        3.48 0.341 21     2.84     4.27\n\nResults are averaged over the levels of: BLOCO \nConfidence level used: 0.95 \nIntervals are back-transformed from the log scale \n```\n\n\n:::\n\n```{.r .cell-code}\ncv <- (sigma(m_campo) / mean(campo$FER)) * 100\ncv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.376265\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(means_campo)\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\nlibrary(multcomp)\ncld(means_campo) #tratamento 6 √© o √∫nico que se diferencia\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n TRAT response    SE df lower.CL upper.CL .group\n 6        2.98 0.292 21     2.43     3.65  1    \n 4        3.08 0.301 21     2.51     3.78  1    \n 5        3.24 0.317 21     2.64     3.97  1    \n 7        3.37 0.330 21     2.75     4.13  1    \n 8        3.48 0.341 21     2.84     4.27  1    \n 3        3.81 0.373 21     3.11     4.67  12   \n 2        5.68 0.556 21     4.63     6.96   2   \n 1       20.02 1.960 21    16.33    24.54    3  \n\nResults are averaged over the levels of: BLOCO \nConfidence level used: 0.95 \nIntervals are back-transformed from the log scale \nP value adjustment: tukey method for comparing a family of 8 estimates \nTests are performed on the log scale \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n\n```{.r .cell-code}\npwpm(means_campo) #fun√ß√£o pwpm faz compara√ß√µes em uma matriz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        1       2       3       4       5       6       7       8\n1 [20.02]  <.0001  <.0001  <.0001  <.0001  <.0001  <.0001  <.0001\n2   3.525 [ 5.68]  0.1252  0.0048  0.0110  0.0028  0.0204  0.0343\n3   5.259   1.492 [ 3.81]  0.7832  0.9335  0.6440  0.9843  0.9976\n4   6.500   1.844   1.236 [ 3.08]  0.9999  1.0000  0.9976  0.9842\n5   6.178   1.753   1.175   0.951 [ 3.24]  0.9984  1.0000  0.9994\n6   6.721   1.906   1.278   1.034   1.088 [ 2.98]  0.9842  0.9431\n7   5.945   1.686   1.130   0.915   0.962   0.885 [ 3.37]  1.0000\n8   5.750   1.631   1.093   0.885   0.931   0.856   0.967 [ 3.48]\n\nRow and column labels: TRAT\nUpper triangle: P values   null = 1  adjust = \"tukey\"\nDiagonal: [Estimates] (response)   type = \"response\"\nLower triangle: Comparisons (ratio)   earlier vs. later\n```\n\n\n:::\n:::\n\n\n\n\n# **An√°lise de Correla√ß√£o de Pearson**\n\nUtilizada para verificar se existe associa√ß√£o linear entre duas vari√°veis quantitativas.\n\nüìå **Quando usar:** Quando se quer avaliar a for√ßa e dire√ß√£o da rela√ß√£o entre duas vari√°veis num√©ricas.\n\nNesse caso, foi calculado o coeficiente de correla√ß√£o entre `FER` (ferrugem) e `PROD` (produtividade), e tamb√©m entre `FER` e `DFC` (desfolha). A fun√ß√£o `cor.test()` foi utilizada para verificar a signific√¢ncia estat√≠stica da correla√ß√£o com `DFC`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor(campo$FER, campo$PROD)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.6259073\n```\n\n\n:::\n\n```{.r .cell-code}\ncor.test(campo$FER, campo$DFC)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tPearson's product-moment correlation\n\ndata:  campo$FER and campo$DFC\nt = 14.049, df = 30, p-value = 9.864e-15\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8635525 0.9664228\nsample estimates:\n      cor \n0.9316978 \n```\n\n\n:::\n:::\n\n\n\n\n# Regress√£o linear simples\n\nTem como objetivo estimar a rela√ß√£o entre uma vari√°vel independente (X) e uma vari√°vel dependente (Y), ajustando uma reta.\n\nüìå **Quando usar:** Para entender a influ√™ncia de uma vari√°vel cont√≠nua sobre outra e gerar modelos preditivos simples.\n\nNesse caso, foram gerados dois gr√°ficos explorat√≥rios com `ggplot2`:\n\n-   Um **gr√°fico de dispers√£o** entre `FER` e `DFC`, com ajuste de linha de regress√£o linear (`geom_smooth(method = 'lm')`):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampo |> \n  ggplot(aes(FER, DFC))+\n  geom_point()+\n  geom_smooth(method = 'lm')\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n-   Um **gr√°fico de produtividade por tratamento**, com pontos ligeiramente deslocados (`geom_jitter`) e barras vermelhas representando m√©dia e intervalo de confian√ßa calculado via bootstrap (`stat_summary()`):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampo |> \n  ggplot(aes(TRAT, PROD))+\n  geom_jitter(width = 0.1)+\n  stat_summary(fun.data = 'mean_cl_boot', colour = 'red', width = 0.3)\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n# An√°lise de Vari√¢ncia (ANOVA) com Modelo Linear\n\nTem como objetivo testar se h√° diferen√ßas estat√≠sticas entre as m√©dias de dois ou mais grupos.\n\nüìå **Quando usar:** Quando se comparam m√©dias entre grupos, especialmente em experimentos com delineamento em blocos.\n\nAqui, um modelo linear foi ajustado para verificar o efeito de diferentes tratamentos (`TRAT`) e blocos (`BLOCO`) sobre a severidade da ferrugem (`FER`, transformada com log). As vari√°veis `TRAT` e `BLOCO` foram convertidas em fatores. Em seguida, foi ajustado um modelo linear do logaritmo da vari√°vel `FER` como resposta, em fun√ß√£o de tratamento e bloco.\n\nA fun√ß√£o `anova()` retornou os efeitos principais. A transforma√ß√£o logar√≠tmica foi utilizada para atender pressupostos de normalidade e homocedasticidade.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampo$TRAT <- factor(campo$TRAT)\ncampo$BLOCO <- factor(campo$BLOCO)\nm_campo <- lm(log(FER) ~ BLOCO + TRAT, data = campo)\nanova(m_campo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: log(FER)\n          Df  Sum Sq Mean Sq F value    Pr(>F)    \nBLOCO      3  0.2064 0.06880  1.7961    0.1788    \nTRAT       7 11.5210 1.64585 42.9665 4.838e-11 ***\nResiduals 21  0.8044 0.03831                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\n\n# Diagn√≥stico de Res√≠duos com DHARMa\n\nTem como objetivo verificar se os res√≠duos do modelo atendem aos pressupostos estat√≠sticos: normalidade, homocedasticidade, independ√™ncia.\n\n-   `simulateResiduals()` simula e plota os res√≠duos.\n\n-   Essencial para validar a adequa√ß√£o do modelo.\n\nüìå **Quando usar:** Sempre ap√≥s ajustar modelos (lm ou lmer), para garantir que as infer√™ncias s√£o confi√°veis.\n\nCom o pacote `DHARMa`, foram simulados e visualizados os res√≠duos do modelo linear para avaliar a adequa√ß√£o do ajuste.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DHARMa)\nplot(simulateResiduals(m_campo))\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n# Compara√ß√£o de m√©dias\n\nTem como objetivo identificar quais grupos (tratamentos) diferem entre si, ap√≥s uma ANOVA significativa.\n\nüìå **Quando usar:** Ap√≥s uma ANOVA significativa, para determinar *quais* grupos s√£o diferentes entre si.\n\n-   O pacote `emmeans()` calcula as m√©dias ajustadas dos tratamentos com base no modelo;\n\n-   C√°lculo do coeficiente de varia√ß√£o com `cv <- (sigma(m_campo) / mean(campo$FER)) * 100`;\n\n-   A fun√ß√£o `cld()` aplica letras distintas a grupos significativamente diferentes.\n\n<!-- -->\n\n-   A fun√ß√£o `pwpm()` mostra compara√ß√µes par a par em forma de matriz.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(emmeans)\nmeans_campo <- emmeans(m_campo, ~ TRAT, type = \"response\")\nmeans_campo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n TRAT response    SE df lower.CL upper.CL\n 1       20.02 1.960 21    16.33    24.54\n 2        5.68 0.556 21     4.63     6.96\n 3        3.81 0.373 21     3.11     4.67\n 4        3.08 0.301 21     2.51     3.78\n 5        3.24 0.317 21     2.64     3.97\n 6        2.98 0.292 21     2.43     3.65\n 7        3.37 0.330 21     2.75     4.13\n 8        3.48 0.341 21     2.84     4.27\n\nResults are averaged over the levels of: BLOCO \nConfidence level used: 0.95 \nIntervals are back-transformed from the log scale \n```\n\n\n:::\n\n```{.r .cell-code}\ncv <- (sigma(m_campo) / mean(campo$FER)) * 100\ncv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.376265\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(means_campo)\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\nlibrary(multcomp)\ncld(means_campo) #tratamento 6 √© o √∫nico que se diferencia\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n TRAT response    SE df lower.CL upper.CL .group\n 6        2.98 0.292 21     2.43     3.65  1    \n 4        3.08 0.301 21     2.51     3.78  1    \n 5        3.24 0.317 21     2.64     3.97  1    \n 7        3.37 0.330 21     2.75     4.13  1    \n 8        3.48 0.341 21     2.84     4.27  1    \n 3        3.81 0.373 21     3.11     4.67  12   \n 2        5.68 0.556 21     4.63     6.96   2   \n 1       20.02 1.960 21    16.33    24.54    3  \n\nResults are averaged over the levels of: BLOCO \nConfidence level used: 0.95 \nIntervals are back-transformed from the log scale \nP value adjustment: tukey method for comparing a family of 8 estimates \nTests are performed on the log scale \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n\n```{.r .cell-code}\npwpm(means_campo) #fun√ß√£o pwpm faz compara√ß√µes em uma matriz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        1       2       3       4       5       6       7       8\n1 [20.02]  <.0001  <.0001  <.0001  <.0001  <.0001  <.0001  <.0001\n2   3.525 [ 5.68]  0.1252  0.0048  0.0110  0.0028  0.0204  0.0343\n3   5.259   1.492 [ 3.81]  0.7832  0.9335  0.6440  0.9843  0.9976\n4   6.500   1.844   1.236 [ 3.08]  0.9999  1.0000  0.9976  0.9842\n5   6.178   1.753   1.175   0.951 [ 3.24]  0.9984  1.0000  0.9994\n6   6.721   1.906   1.278   1.034   1.088 [ 2.98]  0.9842  0.9431\n7   5.945   1.686   1.130   0.915   0.962   0.885 [ 3.37]  1.0000\n8   5.750   1.631   1.093   0.885   0.931   0.856   0.967 [ 3.48]\n\nRow and column labels: TRAT\nUpper triangle: P values   null = 1  adjust = \"tukey\"\nDiagonal: [Estimates] (response)   type = \"response\"\nLower triangle: Comparisons (ratio)   earlier vs. later\n```\n\n\n:::\n:::\n\n\n\n\n# Modelos Lineares Mistos (LMM)\n\nTem como obejivo analisar dados com estrutura hier√°rquica ou com efeitos aleat√≥rios, como blocos, parcelas ou repeti√ß√µes. Permite avaliar o efeito de tratamentos (fixos) controlando varia√ß√µes n√£o controladas (aleat√≥rias), como o efeito de blocos.\n\nüìå **Quando usar:** Em experimentos com estrutura complexa, como blocos aninhados, r√©plicas ou medidas repetidas.\n\n## An√°lise dos dados do experimento com milho\n\nVamos importar a aba `\"milho\"` da mesma planilha, contendo vari√°veis como `hybrid`, `method`, `index`, `yield`, `block`, entre outras. Em seguida, vamos gerar gr√°ficos de dispers√£o para a vari√°vel `index`, coloridos por m√©todo, por h√≠brido e com facetamento por `method`. Utilizamos o operador `interaction()` para criar uma nova vari√°vel identificadora `hybrid_block`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmilho <- readxl::read_excel(\"dados-diversos.xlsx\", sheet = \"milho\")\n# blocos e parcelas \n# parcial subdivididas\n\nmilho |> \n  ggplot(aes(hybrid, index, color = method))+\n  geom_jitter(width = 0.1)+\n  coord_flip()+\n  facet_wrap(~ method)\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmilho$hybrid_block <- interaction(milho$hybrid, milho$block)\n\nmilho |> \n  mutate(hybrid_block = interaction(hybrid,block))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 48 √ó 6\n   hybrid   block method index yield hybrid_block\n   <chr>    <dbl> <chr>  <dbl> <dbl> <fct>       \n 1 30F53 HX     1 pin     21.1 12920 30F53 HX.1  \n 2 30F53 HX     2 pin     21.1  9870 30F53 HX.2  \n 3 30F53 HX     3 pin     23.3  8920 30F53 HX.3  \n 4 30F53 HX     4 pin     35.6 13120 30F53 HX.4  \n 5 30F53 YH     1 pin     21.1 12060 30F53 YH.1  \n 6 30F53 YH     2 pin     22.2  7860 30F53 YH.2  \n 7 30F53 YH     3 pin     27.3  7410 30F53 YH.3  \n 8 30F53 YH     4 pin     27.8 10300 30F53 YH.4  \n 9 30K64        1 pin     20.0 11700 30K64.1     \n10 30K64        2 pin     20.0 10700 30K64.2     \n# ‚Ñπ 38 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# duas formas de modificar -encontrar o identificador de cada hibrido\n```\n:::\n\n\n\n\n## Modelagem mista\n\nUtilizou-se a fun√ß√£o `lmer()` do pacote `lme4` para ajustar um modelo misto com efeitos fixos de `hybrid`, `method` e sua intera√ß√£o, e efeitos aleat√≥rios de blocos aninhados em h√≠bridos. A fun√ß√£o `car::Anova` foi utilizada para tester os efeitos fixos, e os res√≠duos foram simulados com a fun√ß√£o `simulateResiduals()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lme4)\nm_milho <- lmer(index ~ hybrid*method + (1 | block:hybrid_block), data = milho)\ncar::Anova(m_milho)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table (Type II Wald chisquare tests)\n\nResponse: index\n                Chisq Df Pr(>Chisq)   \nhybrid        11.5134  5   0.042099 * \nmethod         4.7263  1   0.029705 * \nhybrid:method 15.7501  5   0.007595 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(simulateResiduals(m_milho))\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# usar o lmer para vari√°veis aleat√≥rias, o modelo lm considera vari√°veis fixas \n\n\n## para yield:\n\nm_milho <- lmer(yield ~ hybrid*method + (1 | block:hybrid_block), data = milho)\ncar::Anova(m_milho)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table (Type II Wald chisquare tests)\n\nResponse: yield\n                Chisq Df Pr(>Chisq)    \nhybrid        22.5971  5   0.000403 ***\nmethod         0.1049  1   0.746069    \nhybrid:method 25.9273  5  9.218e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(simulateResiduals(m_milho))\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n\n```{.r .cell-code}\nmedia_milho <- emmeans(m_milho, ~ method | hybrid)\ncld(media_milho, Letters = letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nhybrid = 30F53 HX:\n method emmean  SE   df lower.CL upper.CL .group\n silk     9988 798 21.1     8329    11647  a    \n pin     11208 798 21.1     9548    12867   b   \n\nhybrid = 30F53 YH:\n method emmean  SE   df lower.CL upper.CL .group\n silk     9211 798 21.1     7552    10870  a    \n pin      9408 798 21.1     7748    11067  a    \n\nhybrid = 30K64:\n method emmean  SE   df lower.CL upper.CL .group\n silk    10361 798 21.1     8702    12020  a    \n pin     11675 798 21.1    10016    13334   b   \n\nhybrid = 30S31H:\n method emmean  SE   df lower.CL upper.CL .group\n pin      8118 798 21.1     6459     9777  a    \n silk     9185 798 21.1     7526    10844   b   \n\nhybrid = 30S31YH:\n method emmean  SE   df lower.CL upper.CL .group\n pin      7836 798 21.1     6177     9495  a    \n silk     8277 798 21.1     6618     9936  a    \n\nhybrid = BG7049H:\n method emmean  SE   df lower.CL upper.CL .group\n pin     11970 798 21.1    10311    13629  a    \n silk    12833 798 21.1    11174    14492  a    \n\nDegrees-of-freedom method: kenward-roger \nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n:::\n\n\n\n\n### Compara√ß√µes m√∫ltiplas\n\nCom `emmeans`, foram estimadas as m√©dias ajustadas por m√©todo dentro de cada h√≠brido. Em seguida, realizou-se o agrupamento com letras via `cld()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedia_milho <- emmeans(m_milho, ~ method | hybrid)\ncld(media_milho, Letters = letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nhybrid = 30F53 HX:\n method emmean  SE   df lower.CL upper.CL .group\n silk     9988 798 21.1     8329    11647  a    \n pin     11208 798 21.1     9548    12867   b   \n\nhybrid = 30F53 YH:\n method emmean  SE   df lower.CL upper.CL .group\n silk     9211 798 21.1     7552    10870  a    \n pin      9408 798 21.1     7748    11067  a    \n\nhybrid = 30K64:\n method emmean  SE   df lower.CL upper.CL .group\n silk    10361 798 21.1     8702    12020  a    \n pin     11675 798 21.1    10016    13334   b   \n\nhybrid = 30S31H:\n method emmean  SE   df lower.CL upper.CL .group\n pin      8118 798 21.1     6459     9777  a    \n silk     9185 798 21.1     7526    10844   b   \n\nhybrid = 30S31YH:\n method emmean  SE   df lower.CL upper.CL .group\n pin      7836 798 21.1     6177     9495  a    \n silk     8277 798 21.1     6618     9936  a    \n\nhybrid = BG7049H:\n method emmean  SE   df lower.CL upper.CL .group\n pin     11970 798 21.1    10311    13629  a    \n silk    12833 798 21.1    11174    14492  a    \n\nDegrees-of-freedom method: kenward-roger \nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n\n```{.r .cell-code}\n# m√©todo pin discrima mais que o m√©todo silk\n```\n:::\n\n\n\n\n### Modelagem para produtividade\n\nRepetiu-se a modelagem mista, agora com a vari√°vel `yield` como resposta. Os procedimentos foram os mesmos: ajuste com `lmer()`, testes com `Anova()` e compara√ß√£o de m√©dias com `emmeans` e `cld()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## para yield:\nm_milho <- lmer(yield ~ hybrid*method + (1 | block:hybrid_block), data = milho)\ncar::Anova(m_milho)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table (Type II Wald chisquare tests)\n\nResponse: yield\n                Chisq Df Pr(>Chisq)    \nhybrid        22.5971  5   0.000403 ***\nmethod         0.1049  1   0.746069    \nhybrid:method 25.9273  5  9.218e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(simulateResiduals(m_milho))\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmedia_milho <- emmeans(m_milho, ~ method | hybrid)\ncld(media_milho, Letters = letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nhybrid = 30F53 HX:\n method emmean  SE   df lower.CL upper.CL .group\n silk     9988 798 21.1     8329    11647  a    \n pin     11208 798 21.1     9548    12867   b   \n\nhybrid = 30F53 YH:\n method emmean  SE   df lower.CL upper.CL .group\n silk     9211 798 21.1     7552    10870  a    \n pin      9408 798 21.1     7748    11067  a    \n\nhybrid = 30K64:\n method emmean  SE   df lower.CL upper.CL .group\n silk    10361 798 21.1     8702    12020  a    \n pin     11675 798 21.1    10016    13334   b   \n\nhybrid = 30S31H:\n method emmean  SE   df lower.CL upper.CL .group\n pin      8118 798 21.1     6459     9777  a    \n silk     9185 798 21.1     7526    10844   b   \n\nhybrid = 30S31YH:\n method emmean  SE   df lower.CL upper.CL .group\n pin      7836 798 21.1     6177     9495  a    \n silk     8277 798 21.1     6618     9936  a    \n\nhybrid = BG7049H:\n method emmean  SE   df lower.CL upper.CL .group\n pin     11970 798 21.1    10311    13629  a    \n silk    12833 798 21.1    11174    14492  a    \n\nDegrees-of-freedom method: kenward-roger \nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n:::\n\n\n\n\n# Coeficiente de Determina√ß√£o (R¬≤)\n\nTem como objetivo indicar a propor√ß√£o da variabilidade de uma vari√°vel que √© explicada por outra. Um R¬≤ baixo indica rela√ß√£o fraca entre as vari√°veis.\n\nüìå **Quando usar:** Para avaliar a qualidade de ajuste de um modelo de regress√£o ou o poder preditivo entre vari√°veis.\n\n## Rela√ß√£o entre √≠ndice e produtividade\n\nPor fim, foi avaliada a associa√ß√£o entre o √≠ndice (`index`) e a produtividade (`yield`) com:\n\n-   Gr√°fico de dispers√£o com linha de regress√£o;\n\n-   C√°lculo da correla√ß√£o de Pearson;\n\n-   C√°lculo do coeficiente de determina√ß√£o (R¬≤) manualmente: `cor^2 * 100`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### RELA√á√ÉO DE INDEX E YIELD\n\nmilho |> \n  ggplot(aes(index, yield))+\n  geom_point()+\n  geom_smooth(method = 'lm')\n```\n\n::: {.cell-output-display}\n![](aula4_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\n## coeficiente de determina√ß√£o mostra a varia√ß√£o de x em fun√ß√£o de y\n\ncor1 <- cor(milho$index, milho$yield)\ncor1*cor1*100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.371246\n```\n\n\n:::\n\n```{.r .cell-code}\n# valor muito baixo est√° indicando que a rela√ß√£o entre eles √© baixa\n\ncor.test(milho$index, milho$yield)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tPearson's product-moment correlation\n\ndata:  milho$index and milho$yield\nt = -1.7692, df = 46, p-value = 0.08348\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.50064223  0.03417223\nsample estimates:\n       cor \n-0.2524133 \n```\n\n\n:::\n\n```{.r .cell-code}\n# testa a hip√≥tese de associa√ßao entre as duas vari√°veis e mostra se ela √© significativa\n```\n:::\n\n\n\n\n### **Conclus√£o**\n\nA correla√ß√£o entre `index` e `yield` foi estatisticamente significativa, mas de **baixa magnitude**, indicando que o √≠ndice avaliado n√£o explica bem a produtividade.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}