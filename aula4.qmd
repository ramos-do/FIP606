---
title: "Aula 4"
author: Danilo Oliveira Ramos
format: html
---

# An√°lise de dados

## **Importa√ß√£o dos dados**

Foi utilizado o pacote `readxl` para importar a aba `"fungicida_campo"` do arquivo `dados-diversos.xlsx`, contendo dados de produtividade (`PROD`), severidade da ferrugem (`FER`), desfolha (`DFC`), tratamentos (`TRAT`) e blocos (`BLOCO`).

```{r}
## aula 30/04 
library(readxl)

campo <- readxl::read_excel("dados-diversos.xlsx", sheet = "fungicida_campo")



campo$TRAT <- factor(campo$TRAT)
campo$BLOCO <- factor(campo$BLOCO)
m_campo <- lm(log(FER) ~ BLOCO + TRAT, data = campo)
anova(m_campo)

library(tidyverse)
library(emmeans)
library(dplyr)
library(DHARMa)
plot(simulateResiduals(m_campo))

means_campo <- emmeans(m_campo, ~ TRAT, type = "response")
means_campo
cv <- (sigma(m_campo) / mean(campo$FER)) * 100
cv


plot(means_campo)

library(multcomp)
cld(means_campo) #tratamento 6 √© o √∫nico que se diferencia
pwpm(means_campo) #fun√ß√£o pwpm faz compara√ß√µes em uma matriz
```

# **An√°lise de Correla√ß√£o de Pearson**

Utilizada para verificar se existe associa√ß√£o linear entre duas vari√°veis quantitativas.

üìå **Quando usar:** Quando se quer avaliar a for√ßa e dire√ß√£o da rela√ß√£o entre duas vari√°veis num√©ricas.

Nesse caso, foi calculado o coeficiente de correla√ß√£o entre `FER` (ferrugem) e `PROD` (produtividade), e tamb√©m entre `FER` e `DFC` (desfolha). A fun√ß√£o `cor.test()` foi utilizada para verificar a signific√¢ncia estat√≠stica da correla√ß√£o com `DFC`.

```{r}
cor(campo$FER, campo$PROD)
cor.test(campo$FER, campo$DFC)
```

# Regress√£o linear simples

Tem como objetivo estimar a rela√ß√£o entre uma vari√°vel independente (X) e uma vari√°vel dependente (Y), ajustando uma reta.

üìå **Quando usar:** Para entender a influ√™ncia de uma vari√°vel cont√≠nua sobre outra e gerar modelos preditivos simples.

Nesse caso, foram gerados dois gr√°ficos explorat√≥rios com `ggplot2`:

-   Um **gr√°fico de dispers√£o** entre `FER` e `DFC`, com ajuste de linha de regress√£o linear (`geom_smooth(method = 'lm')`):

```{r}
campo |> 
  ggplot(aes(FER, DFC))+
  geom_point()+
  geom_smooth(method = 'lm')
```

-   Um **gr√°fico de produtividade por tratamento**, com pontos ligeiramente deslocados (`geom_jitter`) e barras vermelhas representando m√©dia e intervalo de confian√ßa calculado via bootstrap (`stat_summary()`):

```{r}
campo |> 
  ggplot(aes(TRAT, PROD))+
  geom_jitter(width = 0.1)+
  stat_summary(fun.data = 'mean_cl_boot', colour = 'red', width = 0.3)
```

# An√°lise de Vari√¢ncia (ANOVA) com Modelo Linear

Tem como objetivo testar se h√° diferen√ßas estat√≠sticas entre as m√©dias de dois ou mais grupos.

üìå **Quando usar:** Quando se comparam m√©dias entre grupos, especialmente em experimentos com delineamento em blocos.

Aqui, um modelo linear foi ajustado para verificar o efeito de diferentes tratamentos (`TRAT`) e blocos (`BLOCO`) sobre a severidade da ferrugem (`FER`, transformada com log). As vari√°veis `TRAT` e `BLOCO` foram convertidas em fatores. Em seguida, foi ajustado um modelo linear do logaritmo da vari√°vel `FER` como resposta, em fun√ß√£o de tratamento e bloco.

A fun√ß√£o `anova()` retornou os efeitos principais. A transforma√ß√£o logar√≠tmica foi utilizada para atender pressupostos de normalidade e homocedasticidade.

```{r}
campo$TRAT <- factor(campo$TRAT)
campo$BLOCO <- factor(campo$BLOCO)
m_campo <- lm(log(FER) ~ BLOCO + TRAT, data = campo)
anova(m_campo)
```

# Diagn√≥stico de Res√≠duos com DHARMa

Tem como objetivo verificar se os res√≠duos do modelo atendem aos pressupostos estat√≠sticos: normalidade, homocedasticidade, independ√™ncia.

-   `simulateResiduals()` simula e plota os res√≠duos.

-   Essencial para validar a adequa√ß√£o do modelo.

üìå **Quando usar:** Sempre ap√≥s ajustar modelos (lm ou lmer), para garantir que as infer√™ncias s√£o confi√°veis.

Com o pacote `DHARMa`, foram simulados e visualizados os res√≠duos do modelo linear para avaliar a adequa√ß√£o do ajuste.

```{r}
library(DHARMa)
plot(simulateResiduals(m_campo))
```

# Compara√ß√£o de m√©dias

Tem como objetivo identificar quais grupos (tratamentos) diferem entre si, ap√≥s uma ANOVA significativa.

üìå **Quando usar:** Ap√≥s uma ANOVA significativa, para determinar *quais* grupos s√£o diferentes entre si.

-   O pacote `emmeans()` calcula as m√©dias ajustadas dos tratamentos com base no modelo;

-   C√°lculo do coeficiente de varia√ß√£o com `cv <- (sigma(m_campo) / mean(campo$FER)) * 100`;

-   A fun√ß√£o `cld()` aplica letras distintas a grupos significativamente diferentes.

<!-- -->

-   A fun√ß√£o `pwpm()` mostra compara√ß√µes par a par em forma de matriz.

```{r}
library(emmeans)
means_campo <- emmeans(m_campo, ~ TRAT, type = "response")
means_campo
cv <- (sigma(m_campo) / mean(campo$FER)) * 100
cv

plot(means_campo)

library(multcomp)
cld(means_campo) #tratamento 6 √© o √∫nico que se diferencia
pwpm(means_campo) #fun√ß√£o pwpm faz compara√ß√µes em uma matriz
```

# Modelos Lineares Mistos (LMM)

Tem como obejivo analisar dados com estrutura hier√°rquica ou com efeitos aleat√≥rios, como blocos, parcelas ou repeti√ß√µes. Permite avaliar o efeito de tratamentos (fixos) controlando varia√ß√µes n√£o controladas (aleat√≥rias), como o efeito de blocos.

üìå **Quando usar:** Em experimentos com estrutura complexa, como blocos aninhados, r√©plicas ou medidas repetidas.

## An√°lise dos dados do experimento com milho

Vamos importar a aba `"milho"` da mesma planilha, contendo vari√°veis como `hybrid`, `method`, `index`, `yield`, `block`, entre outras. Em seguida, vamos gerar gr√°ficos de dispers√£o para a vari√°vel `index`, coloridos por m√©todo, por h√≠brido e com facetamento por `method`. Utilizamos o operador `interaction()` para criar uma nova vari√°vel identificadora `hybrid_block`.

```{r}
milho <- readxl::read_excel("dados-diversos.xlsx", sheet = "milho")
# blocos e parcelas 
# parcial subdivididas

milho |> 
  ggplot(aes(hybrid, index, color = method))+
  geom_jitter(width = 0.1)+
  coord_flip()+
  facet_wrap(~ method)

milho$hybrid_block <- interaction(milho$hybrid, milho$block)

milho |> 
  mutate(hybrid_block = interaction(hybrid,block))

# duas formas de modificar -encontrar o identificador de cada hibrido
```

## Modelagem mista

Utilizou-se a fun√ß√£o `lmer()` do pacote `lme4` para ajustar um modelo misto com efeitos fixos de `hybrid`, `method` e sua intera√ß√£o, e efeitos aleat√≥rios de blocos aninhados em h√≠bridos. A fun√ß√£o `car::Anova` foi utilizada para tester os efeitos fixos, e os res√≠duos foram simulados com a fun√ß√£o `simulateResiduals()`.

```{r}
library(lme4)
m_milho <- lmer(index ~ hybrid*method + (1 | block:hybrid_block), data = milho)
car::Anova(m_milho)
plot(simulateResiduals(m_milho))

# usar o lmer para vari√°veis aleat√≥rias, o modelo lm considera vari√°veis fixas 


## para yield:

m_milho <- lmer(yield ~ hybrid*method + (1 | block:hybrid_block), data = milho)
car::Anova(m_milho)
plot(simulateResiduals(m_milho))

media_milho <- emmeans(m_milho, ~ method | hybrid)
cld(media_milho, Letters = letters)
```

### Compara√ß√µes m√∫ltiplas

Com `emmeans`, foram estimadas as m√©dias ajustadas por m√©todo dentro de cada h√≠brido. Em seguida, realizou-se o agrupamento com letras via `cld()`.

```{r}
media_milho <- emmeans(m_milho, ~ method | hybrid)
cld(media_milho, Letters = letters)

# m√©todo pin discrima mais que o m√©todo silk
```

### Modelagem para produtividade

Repetiu-se a modelagem mista, agora com a vari√°vel `yield` como resposta. Os procedimentos foram os mesmos: ajuste com `lmer()`, testes com `Anova()` e compara√ß√£o de m√©dias com `emmeans` e `cld()`.

```{r}
## para yield:
m_milho <- lmer(yield ~ hybrid*method + (1 | block:hybrid_block), data = milho)
car::Anova(m_milho)
plot(simulateResiduals(m_milho))

media_milho <- emmeans(m_milho, ~ method | hybrid)
cld(media_milho, Letters = letters)
```

# Coeficiente de Determina√ß√£o (R¬≤)

Tem como objetivo indicar a propor√ß√£o da variabilidade de uma vari√°vel que √© explicada por outra. Um R¬≤ baixo indica rela√ß√£o fraca entre as vari√°veis.

üìå **Quando usar:** Para avaliar a qualidade de ajuste de um modelo de regress√£o ou o poder preditivo entre vari√°veis.

## Rela√ß√£o entre √≠ndice e produtividade

Por fim, foi avaliada a associa√ß√£o entre o √≠ndice (`index`) e a produtividade (`yield`) com:

-   Gr√°fico de dispers√£o com linha de regress√£o;

-   C√°lculo da correla√ß√£o de Pearson;

-   C√°lculo do coeficiente de determina√ß√£o (R¬≤) manualmente: `cor^2 * 100`.

```{r}
### RELA√á√ÉO DE INDEX E YIELD

milho |> 
  ggplot(aes(index, yield))+
  geom_point()+
  geom_smooth(method = 'lm')

## coeficiente de determina√ß√£o mostra a varia√ß√£o de x em fun√ß√£o de y

cor1 <- cor(milho$index, milho$yield)
cor1*cor1*100
# valor muito baixo est√° indicando que a rela√ß√£o entre eles √© baixa

cor.test(milho$index, milho$yield)
# testa a hip√≥tese de associa√ßao entre as duas vari√°veis e mostra se ela √© significativa
```

### **Conclus√£o**

A correla√ß√£o entre `index` e `yield` foi estatisticamente significativa, mas de **baixa magnitude**, indicando que o √≠ndice avaliado n√£o explica bem a produtividade.
